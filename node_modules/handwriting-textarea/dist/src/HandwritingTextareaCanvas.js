var _ctx, _recognizer, _drawing, _activeOperation, _recognitionTimeoutHandle, _resizeObserver, _animationHelper;
import { __classPrivateFieldGet, __classPrivateFieldSet, __decorate } from "tslib";
import { css, html, LitElement } from 'lit';
import { property, query } from 'lit/decorators.js';
import { AnimationHelper } from './AnimationHelper.js';
import { RecognizeEvent } from './RecognizeEvent.js';
import { RequestAnimationDataEvent } from './RequestAnimationDataEvent.js';
/* global HandwritingDrawing, HandwritingRecognizer, HandwritingStroke */
const RECOGNITION_TIMEOUT_IN_MS = 1000;
export class HandwritingTextareaCanvas extends LitElement {
    constructor() {
        super(...arguments);
        _ctx.set(this, void 0);
        _recognizer.set(this, void 0);
        _drawing.set(this, void 0);
        _activeOperation.set(this, void 0);
        _recognitionTimeoutHandle.set(this, void 0);
        _resizeObserver.set(this, void 0);
        _animationHelper.set(this, new AnimationHelper());
    }
    firstUpdated() {
        // Resize the canvas when the textarea size changes
        __classPrivateFieldSet(this, _resizeObserver, new ResizeObserver(() => this.__initializeCanvas()));
        __classPrivateFieldGet(this, _resizeObserver).observe(this);
    }
    __initializeCanvas() {
        if (!this.canvas) {
            throw new Error('Unable to find canvas.');
        }
        // assign canvas's width & height for high-DPI screens
        const clientRect = this.canvas.getBoundingClientRect();
        this.canvas.width = clientRect.width * window.devicePixelRatio;
        this.canvas.height = clientRect.height * window.devicePixelRatio;
        // after canvas resize, all state is lost, so we re-create the context
        // use desynchronized context for performant drawing
        const ctx = this.canvas.getContext('2d', { desynchronized: true });
        if (!ctx) {
            throw new Error('Unable to retrieve 2D context.');
        }
        // initialize pointer style
        ctx.strokeStyle = 'black';
        ctx.lineCap = 'round';
        ctx.lineWidth = 2;
        // map canvas pixels to match pointer pixels
        ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
        __classPrivateFieldSet(this, _ctx, ctx);
    }
    __onPointerDown(event) {
        var _a;
        event.preventDefault();
        if (__classPrivateFieldGet(this, _activeOperation)) {
            // Only support one pointer at a time
            return;
        }
        if (!__classPrivateFieldGet(this, _recognizer)) {
            // The recognizer is only created once in the lifetime of this component.
            // We need to create it here to get access of the pointer type to pass
            // it as a hint to the recognizer.
            this.__setUpRecognizer(event.pointerType);
        }
        __classPrivateFieldSet(this, _activeOperation, {
            stroke: new HandwritingStroke(),
            // store startTime as a reference point for subsequent events
            startTime: Date.now(),
            // store ID to recognize the pointer during pointermove & pointerup
            pointerId: event.pointerId,
        });
        this.__addPoint(event.offsetX, event.offsetY);
        (_a = __classPrivateFieldGet(this, _ctx)) === null || _a === void 0 ? void 0 : _a.moveTo(event.offsetX, event.offsetY);
        // Clear any previous recognition timeout, canvas won't disappear anymore
        this.__clearRecognitionTimeout();
    }
    async __setUpRecognizer(pointerType) {
        var _a, _b;
        if (typeof navigator.createHandwritingRecognizer === 'undefined') {
            throw new Error('Handwriting Recognizer API is not supported on this platform.');
        }
        __classPrivateFieldSet(this, _recognizer, await navigator.createHandwritingRecognizer({
            languages: (_b = (_a = this.languages) === null || _a === void 0 ? void 0 : _a.split(',')) !== null && _b !== void 0 ? _b : [],
        }));
        // Make sure the pointerType matches the allowed values for recognitionType
        const allowedTypes = ['mouse', 'pen', 'touch'];
        const inputType = allowedTypes.find(type => type === pointerType);
        __classPrivateFieldSet(this, _drawing, __classPrivateFieldGet(this, _recognizer).startDrawing({
            inputType,
            textContext: this.textContext,
            recognitionType: this.recognitionType,
            alternatives: 0,
        }));
    }
    __onPointerMove(event) {
        var _a, _b, _c;
        if (((_a = __classPrivateFieldGet(this, _activeOperation)) === null || _a === void 0 ? void 0 : _a.pointerId) === event.pointerId) {
            this.__addPoint(event.offsetX, event.offsetY);
            (_b = __classPrivateFieldGet(this, _ctx)) === null || _b === void 0 ? void 0 : _b.lineTo(event.offsetX, event.offsetY);
            (_c = __classPrivateFieldGet(this, _ctx)) === null || _c === void 0 ? void 0 : _c.stroke();
        }
    }
    __addPoint(x, y) {
        var _a;
        (_a = __classPrivateFieldGet(this, _activeOperation)) === null || _a === void 0 ? void 0 : _a.stroke.addPoint({
            x,
            y,
            t: Date.now() - __classPrivateFieldGet(this, _activeOperation).startTime,
        });
    }
    __onPointerUp(event) {
        var _a;
        if (__classPrivateFieldGet(this, _drawing) && ((_a = __classPrivateFieldGet(this, _activeOperation)) === null || _a === void 0 ? void 0 : _a.pointerId) === event.pointerId) {
            __classPrivateFieldGet(this, _drawing).addStroke(__classPrivateFieldGet(this, _activeOperation).stroke);
            __classPrivateFieldSet(this, _activeOperation, undefined);
            // Set a timeout for recognizing the text and hiding the canvas
            this.__setRecognitionTimeout();
        }
    }
    __setRecognitionTimeout() {
        this.__clearRecognitionTimeout();
        __classPrivateFieldSet(this, _recognitionTimeoutHandle, window.setTimeout(() => this.__predictAndSendEvent(), RECOGNITION_TIMEOUT_IN_MS));
    }
    __clearRecognitionTimeout() {
        if (__classPrivateFieldGet(this, _recognitionTimeoutHandle)) {
            window.clearTimeout(__classPrivateFieldGet(this, _recognitionTimeoutHandle));
        }
    }
    async __predictAndSendEvent() {
        var _a, _b, _c, _d;
        const [prediction] = (_b = (await ((_a = __classPrivateFieldGet(this, _drawing)) === null || _a === void 0 ? void 0 : _a.getPrediction()))) !== null && _b !== void 0 ? _b : [];
        if (prediction && __classPrivateFieldGet(this, _drawing) && __classPrivateFieldGet(this, _ctx)) {
            // request animation data from the textarea
            const requestAnimationDataEvent = new RequestAnimationDataEvent();
            this.dispatchEvent(requestAnimationDataEvent);
            // play the recognition animation
            await __classPrivateFieldGet(this, _animationHelper).animate((_c = this.textContext) !== null && _c !== void 0 ? _c : '', prediction, __classPrivateFieldGet(this, _drawing), __classPrivateFieldGet(this, _ctx), requestAnimationDataEvent.data);
            this.dispatchEvent(new RecognizeEvent((_d = prediction === null || prediction === void 0 ? void 0 : prediction.text) !== null && _d !== void 0 ? _d : ''));
        }
        else {
            this.dispatchEvent(new RecognizeEvent(''));
        }
    }
    render() {
        return html `
      <canvas
        @pointerdown="${(event) => this.__onPointerDown(event)}"
        @pointermove="${(event) => this.__onPointerMove(event)}"
        @pointerup="${(event) => this.__onPointerUp(event)}"
      ></canvas>
      <handwriting-textarea-button
        @click="${() => this.__predictAndSendEvent()}"
        >âœ“
      </handwriting-textarea-button>
    `;
    }
    disconnectedCallback() {
        var _a;
        (_a = __classPrivateFieldGet(this, _resizeObserver)) === null || _a === void 0 ? void 0 : _a.disconnect();
        super.disconnectedCallback();
    }
}
_ctx = new WeakMap(), _recognizer = new WeakMap(), _drawing = new WeakMap(), _activeOperation = new WeakMap(), _recognitionTimeoutHandle = new WeakMap(), _resizeObserver = new WeakMap(), _animationHelper = new WeakMap();
HandwritingTextareaCanvas.styles = css `
    canvas {
      box-sizing: border-box;
      width: 100%;
      height: 100%;
      border: 1px solid dimgray;
      touch-action: none;

      background-color: rgba(255 255 255 / 0.5);
      backdrop-filter: blur(3px);
    }

    handwriting-textarea-button {
      position: absolute;
      bottom: 10px;
      right: 10px;
      background-color: #4caf50;
    }

    handwriting-textarea-button:hover {
      background-color: #66bb6a;
    }
  `;
__decorate([
    query('canvas')
], HandwritingTextareaCanvas.prototype, "canvas", void 0);
__decorate([
    property({ type: String })
], HandwritingTextareaCanvas.prototype, "languages", void 0);
__decorate([
    property({ type: String })
], HandwritingTextareaCanvas.prototype, "textContext", void 0);
__decorate([
    property({ type: String })
], HandwritingTextareaCanvas.prototype, "recognitionType", void 0);
//# sourceMappingURL=HandwritingTextareaCanvas.js.map