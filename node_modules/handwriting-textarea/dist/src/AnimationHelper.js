var _animationTimeoutHandle;
import { __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
import { Easing, Group, Tween } from '@tweenjs/tween.js';
const ANIMATION_DURATION_IN_MS = 280;
export class AnimationHelper {
    constructor() {
        _animationTimeoutHandle.set(this, 0);
    }
    animate(textContext, prediction, drawing, ctx, animationData) {
        // set canvas to textarea font
        ctx.font = `normal ${animationData.fontSize} monospace`;
        // pre-calculate target positions
        const targetPositions = AnimationHelper.__getTargetPositionMap(`${textContext}${prediction.text}`, animationData, ctx);
        const group = AnimationHelper.__getTweenGroupForSegments(textContext, prediction, drawing, ctx, targetPositions, animationData);
        this.__render(ctx, group);
        return new Promise(res => {
            setTimeout(() => {
                res(null);
                cancelAnimationFrame(__classPrivateFieldGet(this, _animationTimeoutHandle));
            }, ANIMATION_DURATION_IN_MS);
        });
    }
    __render(ctx, tweenGroup) {
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        tweenGroup.update();
        __classPrivateFieldSet(this, _animationTimeoutHandle, requestAnimationFrame(() => this.__render(ctx, tweenGroup)));
    }
    static __getTargetPositionMap(text, { width, padding }, ctx) {
        const map = new Map();
        const maxWidth = width - padding;
        let rollingLength = 0;
        let row = 0;
        let column = 0;
        // Perform basic layouting. Does not take word breaks into account.
        // eslint-disable-next-line no-plusplus
        for (let i = 0; i <= text.length; i++) {
            const character = text[i];
            if (character === '\n') {
                row += 1;
                column = 0;
                rollingLength = 0;
            }
            else {
                // As we're only using a monospace font right now, the actual character
                // doesn't matter
                rollingLength += this.__getCharacterMetrics('X', ctx).width;
                if (rollingLength > maxWidth) {
                    row += 1;
                    column = 0;
                    rollingLength = 0;
                }
                else {
                    column += 1;
                }
            }
            map.set(i, { row, column });
        }
        return map;
    }
    static __getTweenGroupForSegments(textContext, prediction, drawing, ctx, positionMap, animationData) {
        var _a;
        const tweenGroup = new Group();
        (_a = prediction.segmentationResult) === null || _a === void 0 ? void 0 : _a.map(segment => ({
            segment,
            sourceRect: this.__getSourceRect(segment.drawingSegments, drawing, ctx.canvas),
        })).map(({ segment, sourceRect }) => ({
            sourceRect,
            canvas: this.__getCanvas(sourceRect, ctx),
            targetRect: this.__getTargetRect(textContext.length, segment, positionMap, animationData, ctx),
        })).forEach(({ sourceRect, targetRect, canvas }) => {
            this.__startTween(sourceRect, targetRect, canvas, tweenGroup, ctx);
        });
        return tweenGroup;
    }
    static __startTween(from, to, graphemeCanvas, tweenGroup, ctx) {
        new Tween({ opacity: 1, ...from }, tweenGroup)
            .to({ opacity: 0, ...to }, ANIMATION_DURATION_IN_MS)
            .easing(Easing.Quadratic.Out)
            .onUpdate(({ x, y, width, height, opacity }) => {
            ctx.canvas.style.opacity = `${opacity}`;
            if (width <= 0 && height <= 0) {
                return;
            }
            ctx.drawImage(graphemeCanvas, x, y, width, height);
        })
            .start();
    }
    static __getCanvas({ x, y, width, height }, ctx) {
        var _a;
        const safeWidth = Math.max(width * devicePixelRatio, devicePixelRatio);
        const safeHeight = Math.max(height * devicePixelRatio, devicePixelRatio);
        // ctx is scaled to devicePixelRatio, but getImageData and putImageData
        // don't respect the transformation matrix
        const imageData = ctx.getImageData(Math.max(x * devicePixelRatio, 0), Math.max(y * devicePixelRatio, 0), safeWidth, safeHeight);
        const canvas = new OffscreenCanvas(safeWidth, safeHeight);
        (_a = canvas.getContext('2d')) === null || _a === void 0 ? void 0 : _a.putImageData(imageData, 0, 0);
        return canvas;
    }
    static __getCharacterMetrics(character, ctx) {
        let metrics = AnimationHelper.characterMetrics.get(character);
        if (metrics) {
            return metrics;
        }
        // cache metrics for given character
        metrics = ctx.measureText(character);
        AnimationHelper.characterMetrics.set(character, metrics);
        return metrics;
    }
    static __getTargetRect(textContextLength, { beginIndex, endIndex }, posMap, { padding, scrollTop }, ctx) {
        const length = endIndex - beginIndex;
        // As we're using monospace fonts, the particular character does not matter
        const { width, emHeightAscent } = AnimationHelper.__getCharacterMetrics('X', ctx);
        const { row, column } = posMap.get(textContextLength + beginIndex);
        return {
            x: padding + column * width,
            y: padding - scrollTop + row * emHeightAscent,
            width: length * width,
            height: emHeightAscent,
        };
    }
    static __getSourceRect(drawingSegments, drawing, canvas) {
        var _a;
        let minX = canvas.width;
        let minY = canvas.height;
        let maxX = 0;
        let maxY = 0;
        for (const segment of drawingSegments) {
            const stroke = drawing.getStrokes()[segment.strokeIndex];
            const points = (_a = stroke === null || stroke === void 0 ? void 0 : stroke.getPoints().filter((_, index) => index >= segment.beginPointIndex && index <= segment.endPointIndex)) !== null && _a !== void 0 ? _a : [];
            const xPoints = points
                .filter((point) => 'x' in point)
                .map(point => point.x);
            const yPoints = points
                .filter((point) => 'y' in point)
                .map(point => point.y);
            minX = Math.min(minX, ...xPoints);
            minY = Math.min(minY, ...yPoints);
            maxX = Math.max(maxX, ...xPoints);
            maxY = Math.max(maxY, ...yPoints);
        }
        return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
    }
}
_animationTimeoutHandle = new WeakMap();
AnimationHelper.characterMetrics = new Map();
//# sourceMappingURL=AnimationHelper.js.map