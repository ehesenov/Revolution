var _hadFocus;
import { __classPrivateFieldGet, __classPrivateFieldSet, __decorate } from "tslib";
import { css, html, LitElement } from 'lit';
import { property, query, state } from 'lit/decorators.js';
export class HandwritingTextarea extends LitElement {
    constructor() {
        super(...arguments);
        this.languages = 'en';
        this.recognitionType = 'text';
        this.value = '';
        this.supported = false;
        this.enabled = false;
        this.textContext = '';
        _hadFocus.set(this, false);
    }
    static get styles() {
        return css `
      :host {
        display: inline-block;
      }

      .wrapper {
        display: grid;
        position: relative;
        height: 100%;
      }

      textarea {
        resize: none;
      }

      handwriting-textarea-button {
        position: absolute;
        bottom: 10px;
        right: 10px;
        transform: scale(-1, 1);
      }

      handwriting-textarea-canvas {
        position: absolute;
        height: 100%;
        width: 100%;
        z-index: 1;
      }
    `;
    }
    async connectedCallback() {
        super.connectedCallback();
        this.supported = await this.__isHandwritingRecognitionSupported();
    }
    async __isHandwritingRecognitionSupported() {
        if (typeof navigator.queryHandwritingRecognizerSupport === 'undefined') {
            // API is not available on this platform
            return false;
        }
        const result = await navigator.queryHandwritingRecognizerSupport({
            languages: this.languages.split(','),
            alternatives: 0,
        });
        if (!result.languages || !result.alternatives) {
            // Handwriting features are not supported. Behave as if API would not be available.
            return false;
        }
        // At this point, both the Handwriting Recognition API and our constraints are supported.
        return true;
    }
    __onRecognize(event) {
        if (this.textarea) {
            // Replace the selected text with the recognized text
            const { before, after } = this.__splitTextAtSelection();
            this.textarea.value = `${before}${event.detail.text}${after}`;
            this.__toggleCanvas();
        }
    }
    __splitTextAtSelection() {
        var _a, _b;
        const text = (_b = (_a = this.textarea) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : '';
        const { start, end } = this.__getSelection();
        return { before: text.substr(0, start), after: text.substr(end) };
    }
    __getSelection() {
        var _a, _b, _c, _d, _e, _f;
        if (!__classPrivateFieldGet(this, _hadFocus)) {
            // if the textarea never had focus, we assume that the user wants to add
            // text add the end (selectionStart and selectionEnd would be 0)
            const length = (_b = (_a = this.textarea) === null || _a === void 0 ? void 0 : _a.value.length) !== null && _b !== void 0 ? _b : 0;
            return { start: length, end: length };
        }
        return {
            start: (_d = (_c = this.textarea) === null || _c === void 0 ? void 0 : _c.selectionStart) !== null && _d !== void 0 ? _d : 0,
            end: (_f = (_e = this.textarea) === null || _e === void 0 ? void 0 : _e.selectionEnd) !== null && _f !== void 0 ? _f : 0,
        };
    }
    __toggleCanvas() {
        this.enabled = this.supported && !this.enabled;
        if (this.enabled) {
            // Set the text before the selection as the context for recognition
            this.textContext = this.__splitTextAtSelection().before;
        }
    }
    __setFocus() {
        __classPrivateFieldSet(this, _hadFocus, true);
    }
    __setValue(event) {
        var _a;
        this.value = (_a = event.target) === null || _a === void 0 ? void 0 : _a.value;
    }
    __onRequestAnimationData(event) {
        if (!this.textarea) {
            throw new Error('Unable to find textarea');
        }
        const { padding, fontSize } = window.getComputedStyle(this.textarea);
        event.setAnimationData({
            width: this.textarea.getBoundingClientRect().width,
            padding: parseInt(padding, 10),
            scrollTop: this.textarea.scrollTop,
            fontSize,
        });
    }
    render() {
        const drawButton = html `
      <handwriting-textarea-button @click="${() => this.__toggleCanvas()}"
        >âœŽ
      </handwriting-textarea-button>
    `;
        const canvas = html `
      <handwriting-textarea-canvas
        languages="${this.languages}"
        recognitiontype="${this.recognitionType}"
        textcontext="${this.textContext}"
        @recognize="${(event) => this.__onRecognize(event)}"
        @requestanimationdata="${(event) => this.__onRequestAnimationData(event)}"
      ></handwriting-textarea-canvas>
    `;
        return html `
      <div class="wrapper">
        <textarea
          .value="${this.value}"
          @input="${(evt) => this.__setValue(evt)}"
          @focus="${() => this.__setFocus()}"
        ></textarea>
        ${this.supported && !this.enabled ? drawButton : ''}
        ${this.enabled ? canvas : ''}
      </div>
    `;
    }
}
_hadFocus = new WeakMap();
__decorate([
    property({ type: String })
], HandwritingTextarea.prototype, "languages", void 0);
__decorate([
    property({ type: String })
], HandwritingTextarea.prototype, "recognitionType", void 0);
__decorate([
    property({ type: String })
], HandwritingTextarea.prototype, "value", void 0);
__decorate([
    state()
], HandwritingTextarea.prototype, "supported", void 0);
__decorate([
    state()
], HandwritingTextarea.prototype, "enabled", void 0);
__decorate([
    state()
], HandwritingTextarea.prototype, "textContext", void 0);
__decorate([
    query('textarea')
], HandwritingTextarea.prototype, "textarea", void 0);
//# sourceMappingURL=HandwritingTextarea.js.map